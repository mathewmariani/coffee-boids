// Generated by CoffeeScript 2.7.0
var Boid;

import Vector2 from './vector2.js';

import Actor from './actor.js';

Boid = (function() {
  class Boid extends Actor {
    constructor(x, y) {
      var color, dx, dy;
      super();
      // constants
      this.size = 8;
      this.radius = 32;
      this.radius2 = this.radius * this.radius;
      color = Math.floor(Math.random() * 256);
      this.fill = `hsla(${color}, 100%, 50%, 0.25)`;
      this.stroke = `hsla(${color}, 100%, 40%, 1.00)`;
      dx = Math.random() * 2 - 1;
      dy = Math.random() * 2 - 1;
      this.position = new Vector2(x, y);
      this.velocity = new Vector2(dx, dy);
      this.velocity.normalize().multiply(this.max_speed);
      Boid.all.push(this);
    }

    getNeighborhood() {
      var b, i, len, neighborhood, ref;
      neighborhood = [];
      ref = Boid.all;
      for (i = 0, len = ref.length; i < len; i++) {
        b = ref[i];
        if (b === this) {
          continue;
        }
        if (Vector2.sqrDistance(this.position, b.position) <= this.radius2) {
          neighborhood.push(b);
        }
      }
      return neighborhood;
    }

    update() {
      this.physics();
      this.wrap();
      this.flock();
    }

    render(ctx) {
      var i, len, pt, ref;
      ctx.fillStyle = this.fill;
      ctx.strokeStyle = this.stroke;
      ctx.save();
      ctx.translate(this.position.x, this.position.y);
      ctx.rotate(Math.atan2(this.forward.y, this.forward.x));
      ctx.beginPath();
      ctx.moveTo(Boid.coords[0].x, Boid.coords[0].y);
      ref = Boid.coords.slice(1);
      for (i = 0, len = ref.length; i < len; i++) {
        pt = ref[i];
        ctx.lineTo(pt.x, pt.y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    flock() {
      var neighborhood;
      neighborhood = this.getNeighborhood();
      if (neighborhood.length === 0) {
        return;
      }
      this.applyForce(this.separation(neighborhood).multiply(4.75));
      this.applyForce(this.alignment(neighborhood).multiply(2.90));
      this.applyForce(this.cohesion(neighborhood).multiply(4.25));
    }

    separation(neighborhood) {
      var average_position, i, len, n;
      average_position = new Vector2(0, 0);
      for (i = 0, len = neighborhood.length; i < len; i++) {
        n = neighborhood[i];
        average_position.add(n.position);
      }
      average_position.divide(neighborhood.length);
      return Vector2.subtract(this.position, average_position).normalize();
    }

    alignment(neighborhood) {
      var average_velocity, i, len, n;
      average_velocity = new Vector2(0, 0);
      for (i = 0, len = neighborhood.length; i < len; i++) {
        n = neighborhood[i];
        average_velocity.add(n.velocity);
      }
      // average_velocity.divide(neighborhood.length)
      return Vector2.subtract(average_velocity, this.velocity).normalize();
    }

    cohesion(neighborhood) {
      var average_position, i, len, n;
      average_position = new Vector2(0, 0);
      for (i = 0, len = neighborhood.length; i < len; i++) {
        n = neighborhood[i];
        average_position.add(n.position);
      }
      average_position.divide(neighborhood.length);
      return Vector2.subtract(average_position, this.position).normalize();
    }

    // check for screen wrapping
    wrap() {
      if (this.position.x < 0) {
        this.position.x += canvas.width;
      } else if (this.position.x > canvas.width) {
        this.position.x -= canvas.width;
      }
      if (this.position.y < 0) {
        this.position.y += canvas.height;
      } else if (this.position.y > canvas.height) {
        this.position.y -= canvas.height;
      }
    }

  };

  // static variable
  Boid.all = [];

  Boid.coords = [
    {
      x: -5,
      y: -2.5
    },
    {
      x: -5,
      y: 2.5
    },
    {
      x: 5,
      y: 0
    }
  ];

  return Boid;

}).call(this);

export default Boid;

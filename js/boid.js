// Generated by CoffeeScript 2.7.0
var Boid;

import Vector2 from './vector2.js';

import Actor from './actor.js';

import {
  shared
} from "./shared.js";

Boid = (function() {
  class Boid extends Actor {
    constructor(x, y) {
      var color, dx, dy;
      super();
      color = Math.floor(Math.random() * 256);
      this.fill = `hsla(${color}, 100%, 50%, 0.25)`;
      this.stroke = `hsla(${color}, 100%, 40%, 1.00)`;
      dx = Math.random() * 2 - 1;
      dy = Math.random() * 2 - 1;
      this.position = new Vector2(x, y);
      this.velocity = new Vector2(dx, dy);
      this.velocity.normalize().multiply(this.max_speed);
      Boid.all.push(this);
    }

    getNeighborhood() {
      var b, i, len, neighborhood, radius2, ref;
      radius2 = shared.boidViewRadius * shared.boidViewRadius;
      neighborhood = [];
      ref = Boid.all;
      for (i = 0, len = ref.length; i < len; i++) {
        b = ref[i];
        if (b === this) {
          continue;
        }
        if (Vector2.sqrDistance(this.position, b.position) <= radius2) {
          if (!this.canSee(b)) {
            continue;
          }
          neighborhood.push(b);
        }
      }
      return neighborhood;
    }

    update() {
      var alignmentForce, avoid, b, center, cohesionForce, count, dist, heading, i, len, offset, offsetToCentre, ref, separationForce;
      this.acceleration = new Vector2(0, 0);
      heading = new Vector2(0, 0);
      avoid = new Vector2(0, 0);
      center = new Vector2(0, 0);
      count = 0;
      ref = Boid.all;
      for (i = 0, len = ref.length; i < len; i++) {
        b = ref[i];
        if (b === this) {
          continue;
        }
        offset = Vector2.subtract(b.position, this.position);
        dist = Vector2.sqrDistance(b.position, this.position);
        if (dist < (shared.boidViewRadius * shared.boidViewRadius)) {
          if (!this.canSee(b)) {
            continue;
          }
          count += 1;
          heading.add(b.forward);
          center.add(b.position);
          if (dist < (shared.boidAvoidanceDist * shared.boidAvoidanceDist)) {
            avoid.subtract(offset.multiply(1 / dist));
          }
        }
      }
      if (count !== 0) {
        offsetToCentre = Vector2.subtract(center.divide(count), this.position);
        alignmentForce = this.steerTowards(heading.divide(count)).multiply(shared.boidAlignmentWeight);
        cohesionForce = this.steerTowards(offsetToCentre).multiply(shared.boidCohesionWeight);
        separationForce = this.steerTowards(avoid).multiply(shared.boidSeparationWeight);
        if (shared.boidUseAlignmentForce) {
          this.applyForce(alignmentForce);
        }
        if (shared.boidUseCohesionForce) {
          this.applyForce(cohesionForce);
        }
        if (shared.boidUseSeparationForce) {
          this.applyForce(separationForce);
        }
      }
      this.physics();
      this.wrap();
    }

    render(ctx) {
      var i, len, pt, ref;
      ctx.save();
      ctx.fillStyle = this.fill;
      ctx.strokeStyle = this.stroke;
      ctx.lineWidth = 2;
      ctx.translate(this.position.x, this.position.y);
      ctx.rotate(Math.atan2(this.forward.y, this.forward.x));
      ctx.beginPath();
      ctx.moveTo(Boid.coords[0].x, Boid.coords[0].y);
      ref = Boid.coords.slice(1);
      for (i = 0, len = ref.length; i < len; i++) {
        pt = ref[i];
        ctx.lineTo(pt.x, pt.y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

  };

  // static variable
  Boid.all = [];

  Boid.coords = [
    {
      x: -5,
      y: -2.5
    },
    {
      x: -5,
      y: 2.5
    },
    {
      x: 5,
      y: 0
    }
  ];

  return Boid;

}).call(this);

export default Boid;
